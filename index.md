# My Summary

## AI利用の原則

1. セーフティファースト
    * 致命的な結果をもたらすような権限を決してAIに与えてはいけない
        * e.g., 機密情報の流出、重要なデータの破壊などに繋がる権限は最初からすべてシャットアウト
    * そのほかはリスクに応じた防御策を
        * 情報の流出リスクをオプションや契約、保険契約で担保するなど
        * 作業場のリスクゼロを求めるとAI利用をあきらめるしかない。だがAI利用を避けること自体がビジネス上の巨大なリスクである
    * 安全が確保されているからこそ積極的に利用できる。セキュリティは邪魔者ではない
2. 十分なコンテキストの用意
    * 必要な情報やツールへのアクセスが良好な生成の土台
    * リスクを許容できる範囲内で上限いっぱいの権限を渡せるのが望ましい
3. 精度に応じたプロンプトの作りこみ
    * ちょっとした内容は思いついたままに聞けば十分。それでも今のAIなら十分な回答を返してくる
    * 高い精度が必要な作業はコンテキストエンジニアリングやプロンプトエンジニアリングを考えるといい
        * そしてできればプロンプトはSkillsなどの機能を使って使いまわす。何度もプロンプトを考えるのは大変なので

## コンテキストエンジニアリング（プロンプトエンジニアリング含む）

* 生成に必要な情報を十分渡し、ノイズ情報を極力減らす
    * 精度を上げ、コストを減らす最良の手段
* 気づきづらいノイズ源は最小限に
    * 自動挿入コンテキストに大量のノイズが含まれていることがある。そういうものを極力減らす。
        * 例えばClaude CodeのCLAUDE.mdと履歴。
* 巨大すぎるプロンプトが必要になるなら、タスクを分割して小さくする
* スクリプトやツールで済むものはそちらを使う
    * そのためのスクリプトやツールをAIに作らせればよい
* 指示を出す前に調査・確認する
    * 雑な指示で生成させたところで全部捨てるはめになる。私はそれで何度も捨てた
* MCP, 公式スキルなどは積極的に利用を
    * あれこれ自分で考えるより良質なものが早く手に入る
* 渡したプロンプトの再現性・トレーサビリティを確保する
    * なにも工夫しないとこうなる「もう一回同じ指示を出したくても出せない。なぜそうなったのかもわからない」
        * これでは途中から生成させなおすことができない
        * 生成されたものが指示通りか確認する術もない（指示が残ってないから）
    * どこでどう確保するかは腕の見せ所
        * リポジトリに保存、ログとしてのこす、Github Issueに残す、本当にいろいろある

## 開発体制の整備

* 開発ルールを整える
    1. 混乱防止: 混乱 -> リンターが複数ある、環境名がバラバラ、必要なテストが人によってあったりなかったりする、なんなら同じ人がやっててもそう
    2. AIの利用効率向上: 逐一指示しなくても「ルール通りにやれ」だけで済む
    3. 品質向上: 例えばフォーマッタ・リンター・静的解析の利用をルールで必須にするだけでも品質は底上げされる
* ワークフローも整える
    * 型通りにやればすむことは型通りにやる。同じタスクは同じ手法で処理する。
    * 都度都度やり方を考えるのは、それしかない時にやること
    * 作業手順、書式のテンプレートなど行えることはたくさんある
* 自動化・仕組化する
    * ルールを全部人間に守らせるのは大変。自動化・仕組化が望ましい
        * 最たるものはCI/CD。フォーマッタのかけ忘れなどはありえなくなる
    * 機械的に行えるのが一番確実だが、難しければAIにやらせる
        * 確実性はやや劣る点にだけ注意すれば十分使い物になる
    * 頻度が高い業務、ミスしやすい業務、認知負荷が高い業務はねらい目
* やりすぎ注意
    * 整備にかかるコストと見返りを常に天秤にかけるべき。
        * 2年に1度、30分で済む単純作業を1か月かけて自動化する合理的理由はない

### 作業記録の資産化

* しっかり残された記録は大事な資産
    * それをもとにAIに調べさせたり分析させたりする
* チケットドリブン + 再現性・トレーサビリティ + バージョン管理システムで実現
    * 楽なのはGithubとGithub IssueとPull Requestに作業を残すこと。CLIやAPI、権限管理の仕組みも充実しておりAIと組み合わせやすい

## Spec Driven

* そのメリット 1)段階的な具体化による品質の担保 2)再現性 3)トレーサビリティ。デメリットは 1) 仕組みの構築が重い
    * 対極と言える手法はVibe Coding。手軽だが品質はまちまちで、もう一度同じことをしたくても難しく、なぜそうなったのかわからない
* AI駆動開発やるなら必須の技術
    * [spec-kit](https://github.com/github/spec-kit)がお手本
        * ただし汎用性を追求している分、そのまま自分のプロジェクトに当てはめて使うのが難しい。実務にはカスタマイズして使うことを推奨
* 実運用は総合力の勝負なのでちょっとづつ実現
    * 要件定義、設計、作業指示書などのドキュメント作成能力
    * 作成したドキュメントの管理能力
    * チーム利用を前提とした改善サイクルと横展開
* 例えばIssueに要件を書き、その要件をClaude Codeに読ませて設計させてリポジトリに保存し、設計を元に作業指示書を作らせたあと実装する
    * これをClaude CodeのSkillsやAgentsを使いながら行うことになる
* 仕組みの構築が重いので少しづつ充実させていくのが現実的
    * AIを使っていても普通に数か月かかる
















